// Code generated by xlsx2proto.
// DO NOT EDIT!

package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"runtime"
	"strconv"
	"strings"

	"games.yol.com/win88/proto"
	"games.yol.com/win88/protocol/server"
	"github.com/tealeg/xlsx"
)

var _ = strings.Split

func AgcConvertDB_ActSign(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_ActSignArray{
			Arr: make([]*server.DB_ActSign, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_ActSign{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.Type = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.Name = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[3].String(), 10, 32)
				data.Item_Id = proto.Int32(int32(temp))

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.Grade = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Activity1(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_Activity1Array{
			Arr: make([]*server.DB_Activity1, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Activity1{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.Parameter = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.Turn = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				data.Title = proto.String(row.Cells[3].String())

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.Costype = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.Costp = proto.Int32(int32(temp))

				if len(row.Cells) < 6+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[6].String(), 10, 32)
				data.Cost = proto.Int32(int32(temp))

				if len(row.Cells) < 7+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[7].String(), 10, 32)
				data.Typee = proto.Int32(int32(temp))

				if len(row.Cells) < 8+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[8].String(), 10, 32)
				data.Propid = proto.Int32(int32(temp))

				if len(row.Cells) < 9+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[9].String(), 10, 32)
				data.Value = proto.Int32(int32(temp))

				if len(row.Cells) < 10+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[10].String(), 10, 32)
				data.Getype = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_AnimalColor(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_AnimalColorArray{
			Arr: make([]*server.DB_AnimalColor, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_AnimalColor{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				data.Desc = proto.String(row.Cells[1].String())

				if len(row.Cells) < 2+1 {
					break
				}

				arrStr = strings.Split(row.Cells[2].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[2].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.ColorChance = arrInt

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_ClientVer(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_ClientVerArray{
			Arr: make([]*server.DB_ClientVer, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_ClientVer{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				data.PackageFlag = proto.String(row.Cells[1].String())

				if len(row.Cells) < 2+1 {
					break
				}

				data.PackVers = proto.String(row.Cells[2].String())

				if len(row.Cells) < 3+1 {
					break
				}

				data.GameVers = proto.String(row.Cells[3].String())

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Createroom(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_CreateroomArray{
			Arr: make([]*server.DB_Createroom, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Createroom{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.GameId = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.GameSite = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				arrStr = strings.Split(row.Cells[3].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[3].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.GoldRange = arrInt

				if len(row.Cells) < 4+1 {
					break
				}

				arrStr = strings.Split(row.Cells[4].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[4].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.BetRange = arrInt

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Fish(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_FishArray{
			Arr: make([]*server.DB_Fish, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Fish{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				data.Name = proto.String(row.Cells[1].String())

				if len(row.Cells) < 2+1 {
					break
				}

				data.NameE = proto.String(row.Cells[2].String())

				if len(row.Cells) < 3+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[3].String(), 10, 32)
				data.Gold = proto.Int32(int32(temp))

				if len(row.Cells) < 4+1 {
					break
				}

				data.Icon = proto.String(row.Cells[4].String())

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.Speed = proto.Int32(int32(temp))

				if len(row.Cells) < 6+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[6].String(), 10, 32)
				data.Exp = proto.Int32(int32(temp))

				if len(row.Cells) < 7+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[7].String(), 10, 32)
				data.FrameCnt = proto.Int32(int32(temp))

				if len(row.Cells) < 8+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[8].String(), 10, 32)
				data.FrameDelay = proto.Int32(int32(temp))

				if len(row.Cells) < 9+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[9].String(), 10, 32)
				data.Rate = proto.Int32(int32(temp))

				if len(row.Cells) < 10+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[10].String(), 10, 32)
				data.ShowType = proto.Int32(int32(temp))

				if len(row.Cells) < 11+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[11].String(), 10, 32)
				data.Show = proto.Int32(int32(temp))

				if len(row.Cells) < 12+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[12].String(), 10, 32)
				data.ShowScale = proto.Int32(int32(temp))

				if len(row.Cells) < 13+1 {
					break
				}

				arrStr = strings.Split(row.Cells[13].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[13].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.ShowPos = arrInt

				if len(row.Cells) < 14+1 {
					break
				}

				data.DieSound = proto.String(row.Cells[14].String())

				if len(row.Cells) < 15+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[15].String(), 10, 32)
				data.DieFrame = proto.Int32(int32(temp))

				if len(row.Cells) < 16+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[16].String(), 10, 32)
				data.DieRotate = proto.Int32(int32(temp))

				if len(row.Cells) < 17+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[17].String(), 10, 32)
				data.DieEffect = proto.Int32(int32(temp))

				if len(row.Cells) < 18+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[18].String(), 10, 32)
				data.DieShake = proto.Int32(int32(temp))

				if len(row.Cells) < 19+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[19].String(), 10, 32)
				data.ShakeRange = proto.Int32(int32(temp))

				if len(row.Cells) < 20+1 {
					break
				}

				data.Shape = proto.String(row.Cells[20].String())

				if len(row.Cells) < 21+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[21].String(), 10, 32)
				data.IsBoss = proto.Int32(int32(temp))

				if len(row.Cells) < 22+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[22].String(), 10, 32)
				data.ResId = proto.Int32(int32(temp))

				if len(row.Cells) < 23+1 {
					break
				}

				data.DieParticle = proto.String(row.Cells[23].String())

				if len(row.Cells) < 24+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[24].String(), 10, 32)
				data.GroupShape = proto.Int32(int32(temp))

				if len(row.Cells) < 25+1 {
					break
				}

				arrStr = strings.Split(row.Cells[25].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[25].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.GroupFishes = arrInt

				if len(row.Cells) < 26+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[26].String(), 10, 32)
				data.Zorder = proto.Int32(int32(temp))

				if len(row.Cells) < 27+1 {
					break
				}

				data.ResPng = proto.String(row.Cells[27].String())

				if len(row.Cells) < 28+1 {
					break
				}

				data.ResPlist = proto.String(row.Cells[28].String())

				if len(row.Cells) < 29+1 {
					break
				}

				data.ExportJson = proto.String(row.Cells[29].String())

				if len(row.Cells) < 30+1 {
					break
				}

				data.AimIcon = proto.String(row.Cells[30].String())

				if len(row.Cells) < 31+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[31].String(), 10, 32)
				data.GameId = proto.Int32(int32(temp))

				if len(row.Cells) < 32+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[32].String(), 10, 32)
				data.Sort = proto.Int32(int32(temp))

				if len(row.Cells) < 33+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[33].String(), 10, 32)
				data.FishType = proto.Int32(int32(temp))

				if len(row.Cells) < 34+1 {
					break
				}

				data.RandomCoin = proto.String(row.Cells[34].String())

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_FishHP(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_FishHPArray{
			Arr: make([]*server.DB_FishHP, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_FishHP{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				data.Name = proto.String(row.Cells[1].String())

				if len(row.Cells) < 2+1 {
					break
				}

				arrStr = strings.Split(row.Cells[2].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[2].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Gold = arrInt

				if len(row.Cells) < 3+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[3].String(), 10, 32)
				data.Rate = proto.Int32(int32(temp))

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.Ratio = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				arrStr = strings.Split(row.Cells[5].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[5].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Ratio1 = arrInt

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_FishHP2(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_FishHP2Array{
			Arr: make([]*server.DB_FishHP2, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_FishHP2{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.Fishid = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				data.Name = proto.String(row.Cells[2].String())

				if len(row.Cells) < 3+1 {
					break
				}

				arrStr = strings.Split(row.Cells[3].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[3].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Gold = arrInt

				if len(row.Cells) < 4+1 {
					break
				}

				arrStr = strings.Split(row.Cells[4].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[4].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Level = arrInt

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_FishPool(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_FishPoolArray{
			Arr: make([]*server.DB_FishPool, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_FishPool{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.SceneType = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.PoolType = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[3].String(), 10, 32)
				data.PoolMin = proto.Int32(int32(temp))

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.PoolMax = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.RateAdd = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_FishRate(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_FishRateArray{
			Arr: make([]*server.DB_FishRate, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_FishRate{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				data.Name = proto.String(row.Cells[1].String())

				if len(row.Cells) < 2+1 {
					break
				}

				arrStr = strings.Split(row.Cells[2].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[2].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Gold = arrInt

				if len(row.Cells) < 3+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[3].String(), 10, 32)
				data.RunGold = proto.Int32(int32(temp))

				if len(row.Cells) < 4+1 {
					break
				}

				arrStr = strings.Split(row.Cells[4].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[4].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.RateA = arrInt

				if len(row.Cells) < 5+1 {
					break
				}

				arrStr = strings.Split(row.Cells[5].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[5].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.RateB = arrInt

				if len(row.Cells) < 6+1 {
					break
				}

				arrStr = strings.Split(row.Cells[6].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[6].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.RateC = arrInt

				if len(row.Cells) < 7+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[7].String(), 10, 32)
				data.PoolType = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_FishRoom(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_FishRoomArray{
			Arr: make([]*server.DB_FishRoom, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_FishRoom{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.RoomId = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				data.Name = proto.String(row.Cells[2].String())

				if len(row.Cells) < 3+1 {
					break
				}

				data.SumGold1 = proto.String(row.Cells[3].String())

				if len(row.Cells) < 4+1 {
					break
				}

				data.SumGold2 = proto.String(row.Cells[4].String())

				if len(row.Cells) < 5+1 {
					break
				}

				data.SumGold3 = proto.String(row.Cells[5].String())

				if len(row.Cells) < 6+1 {
					break
				}

				data.SumGold4 = proto.String(row.Cells[6].String())

				if len(row.Cells) < 7+1 {
					break
				}

				data.SumGold5 = proto.String(row.Cells[7].String())

				if len(row.Cells) < 8+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[8].String(), 10, 32)
				data.BossCDTime = proto.Int32(int32(temp))

				if len(row.Cells) < 9+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[9].String(), 10, 32)
				data.LittleBossCDTime = proto.Int32(int32(temp))

				if len(row.Cells) < 10+1 {
					break
				}

				data.EnableBoss = proto.String(row.Cells[10].String())

				if len(row.Cells) < 11+1 {
					break
				}

				data.EnableLittleBoss = proto.String(row.Cells[11].String())

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_FortuneGod_Odds(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_FortuneGod_OddsArray{
			Arr: make([]*server.DB_FortuneGod_Odds, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_FortuneGod_Odds{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				data.Name = proto.String(row.Cells[1].String())

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.Rateodds3 = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[3].String(), 10, 32)
				data.Rateodds4 = proto.Int32(int32(temp))

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.Rateodds5 = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_FortuneGod_TurnRate(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_FortuneGod_TurnRateArray{
			Arr: make([]*server.DB_FortuneGod_TurnRate, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_FortuneGod_TurnRate{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.ReturnRateMin = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.ReturnRateMax = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				arrStr = strings.Split(row.Cells[3].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[3].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Chance = arrInt

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_FortuneGod_Weight(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_FortuneGod_WeightArray{
			Arr: make([]*server.DB_FortuneGod_Weight, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_FortuneGod_Weight{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				data.Name = proto.String(row.Cells[1].String())

				if len(row.Cells) < 2+1 {
					break
				}

				arrStr = strings.Split(row.Cells[2].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[2].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Weight = arrInt

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_FortuneGod_WeightCondition(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_FortuneGod_WeightConditionArray{
			Arr: make([]*server.DB_FortuneGod_WeightCondition, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_FortuneGod_WeightCondition{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.IsNew = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				arrStr = strings.Split(row.Cells[2].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[2].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.BetScope = arrInt

				if len(row.Cells) < 3+1 {
					break
				}

				arrStr = strings.Split(row.Cells[3].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[3].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.TrueCalcRate = arrInt

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.WeightId = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_GamMatchLV(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_GamMatchLVArray{
			Arr: make([]*server.DB_GamMatchLV, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_GamMatchLV{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				arrStr = strings.Split(row.Cells[1].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[1].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Star = arrInt

				if len(row.Cells) < 2+1 {
					break
				}

				data.Name = proto.String(row.Cells[2].String())

				if len(row.Cells) < 3+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[3].String(), 10, 32)
				data.Star2 = proto.Int32(int32(temp))

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.AwardType1 = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.AwardId1 = proto.Int32(int32(temp))

				if len(row.Cells) < 6+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[6].String(), 10, 32)
				data.Number1 = proto.Int32(int32(temp))

				if len(row.Cells) < 7+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[7].String(), 10, 32)
				data.AwardType2 = proto.Int32(int32(temp))

				if len(row.Cells) < 8+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[8].String(), 10, 32)
				data.AwardId2 = proto.Int32(int32(temp))

				if len(row.Cells) < 9+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[9].String(), 10, 32)
				data.Number2 = proto.Int32(int32(temp))

				if len(row.Cells) < 10+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[10].String(), 10, 32)
				data.AwardType3 = proto.Int32(int32(temp))

				if len(row.Cells) < 11+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[11].String(), 10, 32)
				data.AwardId3 = proto.Int32(int32(temp))

				if len(row.Cells) < 12+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[12].String(), 10, 32)
				data.Number3 = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_GameCoinPool(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_GameCoinPoolArray{
			Arr: make([]*server.DB_GameCoinPool, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_GameCoinPool{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.InitValue = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.LowerLimit = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[3].String(), 10, 32)
				data.UpperLimit = proto.Int32(int32(temp))

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.UpperOffsetLimit = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.MaxOutValue = proto.Int32(int32(temp))

				if len(row.Cells) < 6+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[6].String(), 10, 32)
				data.ChangeRate = proto.Int32(int32(temp))

				if len(row.Cells) < 7+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[7].String(), 10, 32)
				data.MinOutPlayerNum = proto.Int32(int32(temp))

				if len(row.Cells) < 8+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[8].String(), 10, 32)
				data.UpperLimitOfOdds = proto.Int32(int32(temp))

				if len(row.Cells) < 9+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[9].String(), 10, 32)
				data.BaseRate = proto.Int32(int32(temp))

				if len(row.Cells) < 10+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[10].String(), 10, 32)
				data.CtroRate = proto.Int32(int32(temp))

				if len(row.Cells) < 11+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[11].String(), 10, 32)
				data.HardTimeMin = proto.Int32(int32(temp))

				if len(row.Cells) < 12+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[12].String(), 10, 32)
				data.HardTimeMax = proto.Int32(int32(temp))

				if len(row.Cells) < 13+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[13].String(), 10, 32)
				data.NormalTimeMin = proto.Int32(int32(temp))

				if len(row.Cells) < 14+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[14].String(), 10, 32)
				data.NormalTimeMax = proto.Int32(int32(temp))

				if len(row.Cells) < 15+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[15].String(), 10, 32)
				data.EasyTimeMin = proto.Int32(int32(temp))

				if len(row.Cells) < 16+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[16].String(), 10, 32)
				data.EasyTimeMax = proto.Int32(int32(temp))

				if len(row.Cells) < 17+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[17].String(), 10, 32)
				data.EasrierTimeMin = proto.Int32(int32(temp))

				if len(row.Cells) < 18+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[18].String(), 10, 32)
				data.EasrierTimeMax = proto.Int32(int32(temp))

				if len(row.Cells) < 19+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[19].String(), 10, 32)
				data.CpCangeType = proto.Int32(int32(temp))

				if len(row.Cells) < 20+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[20].String(), 10, 32)
				data.CpChangeInterval = proto.Int32(int32(temp))

				if len(row.Cells) < 21+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[21].String(), 10, 32)
				data.CpChangeTotle = proto.Int32(int32(temp))

				if len(row.Cells) < 22+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[22].String(), 10, 32)
				data.CpChangeLower = proto.Int32(int32(temp))

				if len(row.Cells) < 23+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[23].String(), 10, 32)
				data.CpChangeUpper = proto.Int32(int32(temp))

				if len(row.Cells) < 24+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[24].String(), 10, 32)
				data.ProfitRate = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_GameFree(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_GameFreeArray{
			Arr: make([]*server.DB_GameFree, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_GameFree{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				data.Name = proto.String(row.Cells[1].String())

				if len(row.Cells) < 2+1 {
					break
				}

				data.Title = proto.String(row.Cells[2].String())

				if len(row.Cells) < 3+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[3].String(), 10, 32)
				data.GameId = proto.Int32(int32(temp))

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.GameMode = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.GameRule = proto.Int32(int32(temp))

				if len(row.Cells) < 6+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[6].String(), 10, 32)
				data.GameType = proto.Int32(int32(temp))

				if len(row.Cells) < 7+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[7].String(), 10, 32)
				data.SceneType = proto.Int32(int32(temp))

				if len(row.Cells) < 8+1 {
					break
				}

				data.Desc = proto.String(row.Cells[8].String())

				if len(row.Cells) < 9+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[9].String(), 10, 32)
				data.ShowType = proto.Int32(int32(temp))

				if len(row.Cells) < 10+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[10].String(), 10, 32)
				data.SubShowType = proto.Int32(int32(temp))

				if len(row.Cells) < 11+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[11].String(), 10, 32)
				data.Flag = proto.Int32(int32(temp))

				if len(row.Cells) < 12+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[12].String(), 10, 32)
				data.TestTakeCoin = proto.Int32(int32(temp))

				if len(row.Cells) < 13+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[13].String(), 10, 32)
				data.ShowId = proto.Int32(int32(temp))

				if len(row.Cells) < 14+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[14].String(), 10, 32)
				data.LimitCoin = proto.Int32(int32(temp))

				if len(row.Cells) < 15+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[15].String(), 10, 32)
				data.MaxCoinLimit = proto.Int32(int32(temp))

				if len(row.Cells) < 16+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[16].String(), 10, 32)
				data.ServiceFee = proto.Int32(int32(temp))

				if len(row.Cells) < 17+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[17].String(), 10, 32)
				data.LowerThanKick = proto.Int32(int32(temp))

				if len(row.Cells) < 18+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[18].String(), 10, 32)
				data.BaseScore = proto.Int32(int32(temp))

				if len(row.Cells) < 19+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[19].String(), 10, 32)
				data.Turn = proto.Int32(int32(temp))

				if len(row.Cells) < 20+1 {
					break
				}

				data.BetDec = proto.String(row.Cells[20].String())

				if len(row.Cells) < 21+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[21].String(), 10, 32)
				data.Bot = proto.Int32(int32(temp))

				if len(row.Cells) < 22+1 {
					break
				}

				arrStr = strings.Split(row.Cells[22].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[22].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Ai = arrInt

				if len(row.Cells) < 23+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[23].String(), 10, 32)
				data.Banker = proto.Int32(int32(temp))

				if len(row.Cells) < 24+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[24].String(), 10, 32)
				data.MaxChip = proto.Int32(int32(temp))

				if len(row.Cells) < 25+1 {
					break
				}

				arrStr = strings.Split(row.Cells[25].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[25].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.OtherIntParams = arrInt

				if len(row.Cells) < 26+1 {
					break
				}

				arrStr = strings.Split(row.Cells[26].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[26].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Jackpot = arrInt

				if len(row.Cells) < 27+1 {
					break
				}

				arrStr = strings.Split(row.Cells[27].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[27].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.RobotNumRng = arrInt

				if len(row.Cells) < 28+1 {
					break
				}

				arrStr = strings.Split(row.Cells[28].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[28].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.RobotTakeCoin = arrInt

				if len(row.Cells) < 29+1 {
					break
				}

				arrStr = strings.Split(row.Cells[29].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[29].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.RobotLimitCoin = arrInt

				if len(row.Cells) < 30+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[30].String(), 10, 32)
				data.BetLimit = proto.Int32(int32(temp))

				if len(row.Cells) < 31+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[31].String(), 10, 32)
				data.TaxRate = proto.Int32(int32(temp))

				if len(row.Cells) < 32+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[32].String(), 10, 32)
				data.SameIpLimit = proto.Int32(int32(temp))

				if len(row.Cells) < 33+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[33].String(), 10, 32)
				data.SamePlaceLimit = proto.Int32(int32(temp))

				if len(row.Cells) < 34+1 {
					break
				}

				data.GameDif = proto.String(row.Cells[34].String())

				if len(row.Cells) < 35+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[35].String(), 10, 32)
				data.GameClass = proto.Int32(int32(temp))

				if len(row.Cells) < 36+1 {
					break
				}

				data.PlatformName = proto.String(row.Cells[36].String())

				if len(row.Cells) < 37+1 {
					break
				}

				arrStr = strings.Split(row.Cells[37].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[37].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.MaxBetCoin = arrInt

				if len(row.Cells) < 38+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[38].String(), 10, 32)
				data.PlayNumLimit = proto.Int32(int32(temp))

				if len(row.Cells) < 39+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[39].String(), 10, 32)
				data.CreateRoomNum = proto.Int32(int32(temp))

				if len(row.Cells) < 40+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[40].String(), 10, 32)
				data.MatchTrueMan = proto.Int32(int32(temp))

				if len(row.Cells) < 41+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[41].String(), 10, 32)
				data.PlayerWaterRate = proto.Int32(int32(temp))

				if len(row.Cells) < 42+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[42].String(), 10, 32)
				data.MatchMode = proto.Int32(int32(temp))

				if len(row.Cells) < 43+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[43].String(), 10, 32)
				data.KillingRate = proto.Int32(int32(temp))

				if len(row.Cells) < 44+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[44].String(), 10, 32)
				data.BetWaterRate = proto.Int32(int32(temp))

				if len(row.Cells) < 45+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[45].String(), 10, 32)
				data.Lottery = proto.Int32(int32(temp))

				if len(row.Cells) < 46+1 {
					break
				}

				data.LotteryConfig = proto.String(row.Cells[46].String())

				if len(row.Cells) < 47+1 {
					break
				}

				arrStr = strings.Split(row.Cells[47].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[47].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.BalanceLine = arrInt

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_GameItem(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_GameItemArray{
			Arr: make([]*server.DB_GameItem, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_GameItem{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				data.Name = proto.String(row.Cells[1].String())

				if len(row.Cells) < 2+1 {
					break
				}

				arrStr = strings.Split(row.Cells[2].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[2].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.ShowLocation = arrInt

				if len(row.Cells) < 3+1 {
					break
				}

				arrStr = strings.Split(row.Cells[3].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[3].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Classify = arrInt

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.Type = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				arrStr = strings.Split(row.Cells[5].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[5].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Effect0 = arrInt

				if len(row.Cells) < 6+1 {
					break
				}

				arrStr = strings.Split(row.Cells[6].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[6].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Effect = arrInt

				if len(row.Cells) < 7+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[7].String(), 10, 32)
				data.SaleType = proto.Int32(int32(temp))

				if len(row.Cells) < 8+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[8].String(), 10, 32)
				data.SaleGold = proto.Int32(int32(temp))

				if len(row.Cells) < 9+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[9].String(), 10, 32)
				data.Composition = proto.Int32(int32(temp))

				if len(row.Cells) < 10+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[10].String(), 10, 32)
				data.CompositionMax = proto.Int32(int32(temp))

				if len(row.Cells) < 11+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[11].String(), 10, 32)
				data.Time = proto.Int32(int32(temp))

				if len(row.Cells) < 12+1 {
					break
				}

				data.Location = proto.String(row.Cells[12].String())

				if len(row.Cells) < 13+1 {
					break
				}

				data.Describe = proto.String(row.Cells[13].String())

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_GameRule(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_GameRuleArray{
			Arr: make([]*server.DB_GameRule, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_GameRule{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				data.Name = proto.String(row.Cells[1].String())

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.GameId = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[3].String(), 10, 32)
				data.GameMode = proto.Int32(int32(temp))

				if len(row.Cells) < 4+1 {
					break
				}

				arrStr = strings.Split(row.Cells[4].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[4].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Params = arrInt

				if len(row.Cells) < 5+1 {
					break
				}

				data.RuleDesc = proto.String(row.Cells[5].String())

				if len(row.Cells) < 6+1 {
					break
				}

				data.GameDif = proto.String(row.Cells[6].String())

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_GameSubsidy(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_GameSubsidyArray{
			Arr: make([]*server.DB_GameSubsidy, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_GameSubsidy{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.LimitNum = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.Get = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[3].String(), 10, 32)
				data.Times = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Game_Drop(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_Game_DropArray{
			Arr: make([]*server.DB_Game_Drop, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Game_Drop{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.GameId = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.Bet = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[3].String(), 10, 32)
				data.ItemName1 = proto.Int32(int32(temp))

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.ItemId1 = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.Rate1 = proto.Int32(int32(temp))

				if len(row.Cells) < 6+1 {
					break
				}

				arrStr = strings.Split(row.Cells[6].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[6].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Amount1 = arrInt

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Game_Introduction(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_Game_IntroductionArray{
			Arr: make([]*server.DB_Game_Introduction, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Game_Introduction{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.Type = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				data.Name = proto.String(row.Cells[2].String())

				if len(row.Cells) < 3+1 {
					break
				}

				data.Story = proto.String(row.Cells[3].String())

				if len(row.Cells) < 4+1 {
					break
				}

				data.AwardTitle = proto.String(row.Cells[4].String())

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.LevelMax = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Game_Pet(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_Game_PetArray{
			Arr: make([]*server.DB_Game_Pet, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Game_Pet{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.PetId = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				data.Name = proto.String(row.Cells[2].String())

				if len(row.Cells) < 3+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[3].String(), 10, 32)
				data.Grade = proto.Int32(int32(temp))

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.Level = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.Fragment = proto.Int32(int32(temp))

				if len(row.Cells) < 6+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[6].String(), 10, 32)
				data.Amount = proto.Int32(int32(temp))

				if len(row.Cells) < 7+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[7].String(), 10, 32)
				data.AwardType = proto.Int32(int32(temp))

				if len(row.Cells) < 8+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[8].String(), 10, 32)
				data.Award = proto.Int32(int32(temp))

				if len(row.Cells) < 9+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[9].String(), 10, 32)
				data.AwardRate = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Game_Role(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_Game_RoleArray{
			Arr: make([]*server.DB_Game_Role, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Game_Role{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.RoleId = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				data.Name = proto.String(row.Cells[2].String())

				if len(row.Cells) < 3+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[3].String(), 10, 32)
				data.Grade = proto.Int32(int32(temp))

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.Level = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.Fragment = proto.Int32(int32(temp))

				if len(row.Cells) < 6+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[6].String(), 10, 32)
				data.Amount = proto.Int32(int32(temp))

				if len(row.Cells) < 7+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[7].String(), 10, 32)
				data.AwardType = proto.Int32(int32(temp))

				if len(row.Cells) < 8+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[8].String(), 10, 32)
				data.Award = proto.Int32(int32(temp))

				if len(row.Cells) < 9+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[9].String(), 10, 32)
				data.AwardRate = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Legend_Odds(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_Legend_OddsArray{
			Arr: make([]*server.DB_Legend_Odds, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Legend_Odds{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				data.Name = proto.String(row.Cells[1].String())

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.Rateodds3 = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[3].String(), 10, 32)
				data.Rateodds4 = proto.Int32(int32(temp))

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.Rateodds5 = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Legend_TurnRate(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_Legend_TurnRateArray{
			Arr: make([]*server.DB_Legend_TurnRate, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Legend_TurnRate{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.ReturnRateMin = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.ReturnRateMax = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				arrStr = strings.Split(row.Cells[3].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[3].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Chance = arrInt

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Legend_Weight(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_Legend_WeightArray{
			Arr: make([]*server.DB_Legend_Weight, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Legend_Weight{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				data.Name = proto.String(row.Cells[1].String())

				if len(row.Cells) < 2+1 {
					break
				}

				arrStr = strings.Split(row.Cells[2].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[2].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Weight = arrInt

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Legend_WeightCondition(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_Legend_WeightConditionArray{
			Arr: make([]*server.DB_Legend_WeightCondition, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Legend_WeightCondition{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.IsNew = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				arrStr = strings.Split(row.Cells[2].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[2].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.BetScope = arrInt

				if len(row.Cells) < 3+1 {
					break
				}

				arrStr = strings.Split(row.Cells[3].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[3].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.TrueCalcRate = arrInt

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.WeightId = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_MatchRank(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_MatchRankArray{
			Arr: make([]*server.DB_MatchRank, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_MatchRank{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				arrStr = strings.Split(row.Cells[1].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[1].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.RankStar = arrInt

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Name(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_NameArray{
			Arr: make([]*server.DB_Name, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Name{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				data.Name = proto.String(row.Cells[1].String())

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_NameBoy(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_NameBoyArray{
			Arr: make([]*server.DB_NameBoy, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_NameBoy{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				data.Name = proto.String(row.Cells[1].String())

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_NameGirl(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_NameGirlArray{
			Arr: make([]*server.DB_NameGirl, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_NameGirl{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				data.Name = proto.String(row.Cells[1].String())

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_PlayerInfo(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_PlayerInfoArray{
			Arr: make([]*server.DB_PlayerInfo, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_PlayerInfo{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				data.City = proto.String(row.Cells[0].String())

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.Head = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				data.Name = proto.String(row.Cells[2].String())

				if len(row.Cells) < 3+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[3].String(), 10, 32)
				data.Sex = proto.Int32(int32(temp))

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_PlayerType(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_PlayerTypeArray{
			Arr: make([]*server.DB_PlayerType, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_PlayerType{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				data.Name = proto.String(row.Cells[1].String())

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.GameFreeId = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[3].String(), 10, 32)
				data.PayLowerLimit = proto.Int32(int32(temp))

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.PayUpperLimit = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.GameTimeLowerLimit = proto.Int32(int32(temp))

				if len(row.Cells) < 6+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[6].String(), 10, 32)
				data.GameTimeUpperLimit = proto.Int32(int32(temp))

				if len(row.Cells) < 7+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[7].String(), 10, 32)
				data.TotalInLowerLimit = proto.Int32(int32(temp))

				if len(row.Cells) < 8+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[8].String(), 10, 32)
				data.TotalInUpperLimit = proto.Int32(int32(temp))

				if len(row.Cells) < 9+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[9].String(), 10, 32)
				data.OddsLowerLimit = proto.Int32(int32(temp))

				if len(row.Cells) < 10+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[10].String(), 10, 32)
				data.OddsUpperLimit = proto.Int32(int32(temp))

				if len(row.Cells) < 11+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[11].String(), 10, 32)
				data.LuckyRate = proto.Int32(int32(temp))

				if len(row.Cells) < 12+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[12].String(), 10, 32)
				data.ChangeCardRate = proto.Int32(int32(temp))

				if len(row.Cells) < 13+1 {
					break
				}

				arrStr = strings.Split(row.Cells[13].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[13].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.CardValueRange = arrInt

				if len(row.Cells) < 14+1 {
					break
				}

				arrStr = strings.Split(row.Cells[14].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[14].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.MatchPriority = arrInt

				if len(row.Cells) < 15+1 {
					break
				}

				arrStr = strings.Split(row.Cells[15].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[15].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.ExcludeMatch = arrInt

				if len(row.Cells) < 16+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[16].String(), 10, 32)
				data.CardLibRate = proto.Int32(int32(temp))

				if len(row.Cells) < 17+1 {
					break
				}

				arrStr = strings.Split(row.Cells[17].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[17].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.CardLibArr = arrInt

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Policy101(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_Policy101Array{
			Arr: make([]*server.DB_Policy101, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Policy101{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.Time = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.FishId = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				arrStr = strings.Split(row.Cells[3].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[3].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Paths = arrInt

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.Count = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.Speed = proto.Int32(int32(temp))

				if len(row.Cells) < 6+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[6].String(), 10, 32)
				data.Event = proto.Int32(int32(temp))

				if len(row.Cells) < 7+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[7].String(), 10, 32)
				data.RefreshInterval = proto.Int32(int32(temp))

				if len(row.Cells) < 8+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[8].String(), 10, 32)
				data.TimeToLive = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Policy102(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_Policy102Array{
			Arr: make([]*server.DB_Policy102, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Policy102{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.Time = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.FishId = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				arrStr = strings.Split(row.Cells[3].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[3].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Paths = arrInt

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.Count = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.Speed = proto.Int32(int32(temp))

				if len(row.Cells) < 6+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[6].String(), 10, 32)
				data.Event = proto.Int32(int32(temp))

				if len(row.Cells) < 7+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[7].String(), 10, 32)
				data.RefreshInterval = proto.Int32(int32(temp))

				if len(row.Cells) < 8+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[8].String(), 10, 32)
				data.TimeToLive = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Policy103(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_Policy103Array{
			Arr: make([]*server.DB_Policy103, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Policy103{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.Time = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.FishId = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				arrStr = strings.Split(row.Cells[3].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[3].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Paths = arrInt

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.Count = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.Speed = proto.Int32(int32(temp))

				if len(row.Cells) < 6+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[6].String(), 10, 32)
				data.Event = proto.Int32(int32(temp))

				if len(row.Cells) < 7+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[7].String(), 10, 32)
				data.RefreshInterval = proto.Int32(int32(temp))

				if len(row.Cells) < 8+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[8].String(), 10, 32)
				data.TimeToLive = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Policy151(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_Policy151Array{
			Arr: make([]*server.DB_Policy151, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Policy151{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.Time = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.FishId = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				arrStr = strings.Split(row.Cells[3].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[3].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Paths = arrInt

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.Count = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.Speed = proto.Int32(int32(temp))

				if len(row.Cells) < 6+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[6].String(), 10, 32)
				data.Event = proto.Int32(int32(temp))

				if len(row.Cells) < 7+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[7].String(), 10, 32)
				data.RefreshInterval = proto.Int32(int32(temp))

				if len(row.Cells) < 8+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[8].String(), 10, 32)
				data.TimeToLive = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Policy152(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_Policy152Array{
			Arr: make([]*server.DB_Policy152, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Policy152{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.Time = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.FishId = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				arrStr = strings.Split(row.Cells[3].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[3].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Paths = arrInt

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.Count = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.Speed = proto.Int32(int32(temp))

				if len(row.Cells) < 6+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[6].String(), 10, 32)
				data.Event = proto.Int32(int32(temp))

				if len(row.Cells) < 7+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[7].String(), 10, 32)
				data.RefreshInterval = proto.Int32(int32(temp))

				if len(row.Cells) < 8+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[8].String(), 10, 32)
				data.TimeToLive = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Policy153(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_Policy153Array{
			Arr: make([]*server.DB_Policy153, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Policy153{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.Time = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.FishId = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				arrStr = strings.Split(row.Cells[3].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[3].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Paths = arrInt

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.Count = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.Speed = proto.Int32(int32(temp))

				if len(row.Cells) < 6+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[6].String(), 10, 32)
				data.Event = proto.Int32(int32(temp))

				if len(row.Cells) < 7+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[7].String(), 10, 32)
				data.RefreshInterval = proto.Int32(int32(temp))

				if len(row.Cells) < 8+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[8].String(), 10, 32)
				data.TimeToLive = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Policy201(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_Policy201Array{
			Arr: make([]*server.DB_Policy201, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Policy201{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.Time = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.FishId = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				arrStr = strings.Split(row.Cells[3].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[3].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Paths = arrInt

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.Count = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.Speed = proto.Int32(int32(temp))

				if len(row.Cells) < 6+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[6].String(), 10, 32)
				data.Event = proto.Int32(int32(temp))

				if len(row.Cells) < 7+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[7].String(), 10, 32)
				data.RefreshInterval = proto.Int32(int32(temp))

				if len(row.Cells) < 8+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[8].String(), 10, 32)
				data.TimeToLive = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Policy202(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_Policy202Array{
			Arr: make([]*server.DB_Policy202, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Policy202{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.Time = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.FishId = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				arrStr = strings.Split(row.Cells[3].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[3].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Paths = arrInt

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.Count = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.Speed = proto.Int32(int32(temp))

				if len(row.Cells) < 6+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[6].String(), 10, 32)
				data.Event = proto.Int32(int32(temp))

				if len(row.Cells) < 7+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[7].String(), 10, 32)
				data.RefreshInterval = proto.Int32(int32(temp))

				if len(row.Cells) < 8+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[8].String(), 10, 32)
				data.TimeToLive = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Policy203(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_Policy203Array{
			Arr: make([]*server.DB_Policy203, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Policy203{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.Time = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.FishId = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				arrStr = strings.Split(row.Cells[3].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[3].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Paths = arrInt

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.Count = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.Speed = proto.Int32(int32(temp))

				if len(row.Cells) < 6+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[6].String(), 10, 32)
				data.Event = proto.Int32(int32(temp))

				if len(row.Cells) < 7+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[7].String(), 10, 32)
				data.RefreshInterval = proto.Int32(int32(temp))

				if len(row.Cells) < 8+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[8].String(), 10, 32)
				data.TimeToLive = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Policy251(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_Policy251Array{
			Arr: make([]*server.DB_Policy251, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Policy251{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.Time = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.FishId = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				arrStr = strings.Split(row.Cells[3].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[3].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Paths = arrInt

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.Count = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.Speed = proto.Int32(int32(temp))

				if len(row.Cells) < 6+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[6].String(), 10, 32)
				data.Event = proto.Int32(int32(temp))

				if len(row.Cells) < 7+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[7].String(), 10, 32)
				data.RefreshInterval = proto.Int32(int32(temp))

				if len(row.Cells) < 8+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[8].String(), 10, 32)
				data.TimeToLive = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Policy252(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_Policy252Array{
			Arr: make([]*server.DB_Policy252, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Policy252{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.Time = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.FishId = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				arrStr = strings.Split(row.Cells[3].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[3].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Paths = arrInt

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.Count = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.Speed = proto.Int32(int32(temp))

				if len(row.Cells) < 6+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[6].String(), 10, 32)
				data.Event = proto.Int32(int32(temp))

				if len(row.Cells) < 7+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[7].String(), 10, 32)
				data.RefreshInterval = proto.Int32(int32(temp))

				if len(row.Cells) < 8+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[8].String(), 10, 32)
				data.TimeToLive = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Policy253(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_Policy253Array{
			Arr: make([]*server.DB_Policy253, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Policy253{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.Time = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.FishId = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				arrStr = strings.Split(row.Cells[3].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[3].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Paths = arrInt

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.Count = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.Speed = proto.Int32(int32(temp))

				if len(row.Cells) < 6+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[6].String(), 10, 32)
				data.Event = proto.Int32(int32(temp))

				if len(row.Cells) < 7+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[7].String(), 10, 32)
				data.RefreshInterval = proto.Int32(int32(temp))

				if len(row.Cells) < 8+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[8].String(), 10, 32)
				data.TimeToLive = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Policy301(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_Policy301Array{
			Arr: make([]*server.DB_Policy301, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Policy301{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.Time = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.FishId = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				arrStr = strings.Split(row.Cells[3].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[3].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Paths = arrInt

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.Count = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.Speed = proto.Int32(int32(temp))

				if len(row.Cells) < 6+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[6].String(), 10, 32)
				data.Event = proto.Int32(int32(temp))

				if len(row.Cells) < 7+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[7].String(), 10, 32)
				data.RefreshInterval = proto.Int32(int32(temp))

				if len(row.Cells) < 8+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[8].String(), 10, 32)
				data.TimeToLive = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Policy302(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_Policy302Array{
			Arr: make([]*server.DB_Policy302, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Policy302{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.Time = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.FishId = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				arrStr = strings.Split(row.Cells[3].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[3].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Paths = arrInt

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.Count = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.Speed = proto.Int32(int32(temp))

				if len(row.Cells) < 6+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[6].String(), 10, 32)
				data.Event = proto.Int32(int32(temp))

				if len(row.Cells) < 7+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[7].String(), 10, 32)
				data.RefreshInterval = proto.Int32(int32(temp))

				if len(row.Cells) < 8+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[8].String(), 10, 32)
				data.TimeToLive = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Policy303(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_Policy303Array{
			Arr: make([]*server.DB_Policy303, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Policy303{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.Time = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.FishId = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				arrStr = strings.Split(row.Cells[3].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[3].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Paths = arrInt

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.Count = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.Speed = proto.Int32(int32(temp))

				if len(row.Cells) < 6+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[6].String(), 10, 32)
				data.Event = proto.Int32(int32(temp))

				if len(row.Cells) < 7+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[7].String(), 10, 32)
				data.RefreshInterval = proto.Int32(int32(temp))

				if len(row.Cells) < 8+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[8].String(), 10, 32)
				data.TimeToLive = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Policy351(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_Policy351Array{
			Arr: make([]*server.DB_Policy351, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Policy351{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.Time = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.FishId = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				arrStr = strings.Split(row.Cells[3].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[3].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Paths = arrInt

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.Count = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.Speed = proto.Int32(int32(temp))

				if len(row.Cells) < 6+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[6].String(), 10, 32)
				data.Event = proto.Int32(int32(temp))

				if len(row.Cells) < 7+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[7].String(), 10, 32)
				data.RefreshInterval = proto.Int32(int32(temp))

				if len(row.Cells) < 8+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[8].String(), 10, 32)
				data.TimeToLive = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Policy352(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_Policy352Array{
			Arr: make([]*server.DB_Policy352, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Policy352{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.Time = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.FishId = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				arrStr = strings.Split(row.Cells[3].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[3].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Paths = arrInt

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.Count = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.Speed = proto.Int32(int32(temp))

				if len(row.Cells) < 6+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[6].String(), 10, 32)
				data.Event = proto.Int32(int32(temp))

				if len(row.Cells) < 7+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[7].String(), 10, 32)
				data.RefreshInterval = proto.Int32(int32(temp))

				if len(row.Cells) < 8+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[8].String(), 10, 32)
				data.TimeToLive = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Policy353(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_Policy353Array{
			Arr: make([]*server.DB_Policy353, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Policy353{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.Time = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.FishId = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				arrStr = strings.Split(row.Cells[3].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[3].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Paths = arrInt

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.Count = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.Speed = proto.Int32(int32(temp))

				if len(row.Cells) < 6+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[6].String(), 10, 32)
				data.Event = proto.Int32(int32(temp))

				if len(row.Cells) < 7+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[7].String(), 10, 32)
				data.RefreshInterval = proto.Int32(int32(temp))

				if len(row.Cells) < 8+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[8].String(), 10, 32)
				data.TimeToLive = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Policy401(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_Policy401Array{
			Arr: make([]*server.DB_Policy401, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Policy401{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.Time = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.FishId = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				arrStr = strings.Split(row.Cells[3].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[3].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Paths = arrInt

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.Count = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.Speed = proto.Int32(int32(temp))

				if len(row.Cells) < 6+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[6].String(), 10, 32)
				data.Event = proto.Int32(int32(temp))

				if len(row.Cells) < 7+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[7].String(), 10, 32)
				data.RefreshInterval = proto.Int32(int32(temp))

				if len(row.Cells) < 8+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[8].String(), 10, 32)
				data.TimeToLive = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Policy402(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_Policy402Array{
			Arr: make([]*server.DB_Policy402, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Policy402{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.Time = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.FishId = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				arrStr = strings.Split(row.Cells[3].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[3].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Paths = arrInt

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.Count = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.Speed = proto.Int32(int32(temp))

				if len(row.Cells) < 6+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[6].String(), 10, 32)
				data.Event = proto.Int32(int32(temp))

				if len(row.Cells) < 7+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[7].String(), 10, 32)
				data.RefreshInterval = proto.Int32(int32(temp))

				if len(row.Cells) < 8+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[8].String(), 10, 32)
				data.TimeToLive = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Policy403(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_Policy403Array{
			Arr: make([]*server.DB_Policy403, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Policy403{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.Time = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.FishId = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				arrStr = strings.Split(row.Cells[3].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[3].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Paths = arrInt

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.Count = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.Speed = proto.Int32(int32(temp))

				if len(row.Cells) < 6+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[6].String(), 10, 32)
				data.Event = proto.Int32(int32(temp))

				if len(row.Cells) < 7+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[7].String(), 10, 32)
				data.RefreshInterval = proto.Int32(int32(temp))

				if len(row.Cells) < 8+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[8].String(), 10, 32)
				data.TimeToLive = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Policy420(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_Policy420Array{
			Arr: make([]*server.DB_Policy420, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Policy420{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.Time = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.FishId = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				arrStr = strings.Split(row.Cells[3].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[3].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Paths = arrInt

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.Count = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.Speed = proto.Int32(int32(temp))

				if len(row.Cells) < 6+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[6].String(), 10, 32)
				data.Event = proto.Int32(int32(temp))

				if len(row.Cells) < 7+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[7].String(), 10, 32)
				data.RefreshInterval = proto.Int32(int32(temp))

				if len(row.Cells) < 8+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[8].String(), 10, 32)
				data.TimeToLive = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Policy451(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_Policy451Array{
			Arr: make([]*server.DB_Policy451, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Policy451{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.Time = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.FishId = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				arrStr = strings.Split(row.Cells[3].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[3].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Paths = arrInt

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.Count = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.Speed = proto.Int32(int32(temp))

				if len(row.Cells) < 6+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[6].String(), 10, 32)
				data.Event = proto.Int32(int32(temp))

				if len(row.Cells) < 7+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[7].String(), 10, 32)
				data.RefreshInterval = proto.Int32(int32(temp))

				if len(row.Cells) < 8+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[8].String(), 10, 32)
				data.TimeToLive = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Policy452(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_Policy452Array{
			Arr: make([]*server.DB_Policy452, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Policy452{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.Time = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.FishId = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				arrStr = strings.Split(row.Cells[3].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[3].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Paths = arrInt

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.Count = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.Speed = proto.Int32(int32(temp))

				if len(row.Cells) < 6+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[6].String(), 10, 32)
				data.Event = proto.Int32(int32(temp))

				if len(row.Cells) < 7+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[7].String(), 10, 32)
				data.RefreshInterval = proto.Int32(int32(temp))

				if len(row.Cells) < 8+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[8].String(), 10, 32)
				data.TimeToLive = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Policy453(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_Policy453Array{
			Arr: make([]*server.DB_Policy453, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Policy453{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.Time = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.FishId = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				arrStr = strings.Split(row.Cells[3].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[3].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Paths = arrInt

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.Count = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.Speed = proto.Int32(int32(temp))

				if len(row.Cells) < 6+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[6].String(), 10, 32)
				data.Event = proto.Int32(int32(temp))

				if len(row.Cells) < 7+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[7].String(), 10, 32)
				data.RefreshInterval = proto.Int32(int32(temp))

				if len(row.Cells) < 8+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[8].String(), 10, 32)
				data.TimeToLive = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Policy501(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_Policy501Array{
			Arr: make([]*server.DB_Policy501, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Policy501{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.Time = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.FishId = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				arrStr = strings.Split(row.Cells[3].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[3].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Paths = arrInt

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.Count = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.Speed = proto.Int32(int32(temp))

				if len(row.Cells) < 6+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[6].String(), 10, 32)
				data.Event = proto.Int32(int32(temp))

				if len(row.Cells) < 7+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[7].String(), 10, 32)
				data.RefreshInterval = proto.Int32(int32(temp))

				if len(row.Cells) < 8+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[8].String(), 10, 32)
				data.TimeToLive = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Policy502(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_Policy502Array{
			Arr: make([]*server.DB_Policy502, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Policy502{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.Time = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.FishId = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				arrStr = strings.Split(row.Cells[3].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[3].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Paths = arrInt

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.Count = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.Speed = proto.Int32(int32(temp))

				if len(row.Cells) < 6+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[6].String(), 10, 32)
				data.Event = proto.Int32(int32(temp))

				if len(row.Cells) < 7+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[7].String(), 10, 32)
				data.RefreshInterval = proto.Int32(int32(temp))

				if len(row.Cells) < 8+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[8].String(), 10, 32)
				data.TimeToLive = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Policy601(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_Policy601Array{
			Arr: make([]*server.DB_Policy601, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Policy601{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.Time = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.FishId = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				arrStr = strings.Split(row.Cells[3].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[3].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Paths = arrInt

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.Count = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.Speed = proto.Int32(int32(temp))

				if len(row.Cells) < 6+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[6].String(), 10, 32)
				data.Event = proto.Int32(int32(temp))

				if len(row.Cells) < 7+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[7].String(), 10, 32)
				data.RefreshInterval = proto.Int32(int32(temp))

				if len(row.Cells) < 8+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[8].String(), 10, 32)
				data.TimeToLive = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Policy701(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_Policy701Array{
			Arr: make([]*server.DB_Policy701, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Policy701{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.Time = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.FishId = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				arrStr = strings.Split(row.Cells[3].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[3].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Paths = arrInt

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.Count = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.Speed = proto.Int32(int32(temp))

				if len(row.Cells) < 6+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[6].String(), 10, 32)
				data.Event = proto.Int32(int32(temp))

				if len(row.Cells) < 7+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[7].String(), 10, 32)
				data.RefreshInterval = proto.Int32(int32(temp))

				if len(row.Cells) < 8+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[8].String(), 10, 32)
				data.TimeToLive = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Policy702(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_Policy702Array{
			Arr: make([]*server.DB_Policy702, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Policy702{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.Time = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.FishId = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				arrStr = strings.Split(row.Cells[3].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[3].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Paths = arrInt

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.Count = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.Speed = proto.Int32(int32(temp))

				if len(row.Cells) < 6+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[6].String(), 10, 32)
				data.Event = proto.Int32(int32(temp))

				if len(row.Cells) < 7+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[7].String(), 10, 32)
				data.RefreshInterval = proto.Int32(int32(temp))

				if len(row.Cells) < 8+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[8].String(), 10, 32)
				data.TimeToLive = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Policy801(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_Policy801Array{
			Arr: make([]*server.DB_Policy801, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Policy801{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.Time = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.FishId = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				arrStr = strings.Split(row.Cells[3].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[3].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Paths = arrInt

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.Count = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.Speed = proto.Int32(int32(temp))

				if len(row.Cells) < 6+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[6].String(), 10, 32)
				data.Event = proto.Int32(int32(temp))

				if len(row.Cells) < 7+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[7].String(), 10, 32)
				data.RefreshInterval = proto.Int32(int32(temp))

				if len(row.Cells) < 8+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[8].String(), 10, 32)
				data.TimeToLive = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Policy802(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_Policy802Array{
			Arr: make([]*server.DB_Policy802, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Policy802{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.Time = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.FishId = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				arrStr = strings.Split(row.Cells[3].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[3].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Paths = arrInt

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.Count = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.Speed = proto.Int32(int32(temp))

				if len(row.Cells) < 6+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[6].String(), 10, 32)
				data.Event = proto.Int32(int32(temp))

				if len(row.Cells) < 7+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[7].String(), 10, 32)
				data.RefreshInterval = proto.Int32(int32(temp))

				if len(row.Cells) < 8+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[8].String(), 10, 32)
				data.TimeToLive = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Policy803(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_Policy803Array{
			Arr: make([]*server.DB_Policy803, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Policy803{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.Time = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.FishId = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				arrStr = strings.Split(row.Cells[3].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[3].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Paths = arrInt

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.Count = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.Speed = proto.Int32(int32(temp))

				if len(row.Cells) < 6+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[6].String(), 10, 32)
				data.Event = proto.Int32(int32(temp))

				if len(row.Cells) < 7+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[7].String(), 10, 32)
				data.RefreshInterval = proto.Int32(int32(temp))

				if len(row.Cells) < 8+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[8].String(), 10, 32)
				data.TimeToLive = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Policy804(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_Policy804Array{
			Arr: make([]*server.DB_Policy804, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Policy804{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.Time = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.FishId = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				arrStr = strings.Split(row.Cells[3].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[3].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Paths = arrInt

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.Count = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.Speed = proto.Int32(int32(temp))

				if len(row.Cells) < 6+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[6].String(), 10, 32)
				data.Event = proto.Int32(int32(temp))

				if len(row.Cells) < 7+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[7].String(), 10, 32)
				data.RefreshInterval = proto.Int32(int32(temp))

				if len(row.Cells) < 8+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[8].String(), 10, 32)
				data.TimeToLive = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Policy805(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_Policy805Array{
			Arr: make([]*server.DB_Policy805, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Policy805{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.Time = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.FishId = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				arrStr = strings.Split(row.Cells[3].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[3].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Paths = arrInt

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.Count = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.Speed = proto.Int32(int32(temp))

				if len(row.Cells) < 6+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[6].String(), 10, 32)
				data.Event = proto.Int32(int32(temp))

				if len(row.Cells) < 7+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[7].String(), 10, 32)
				data.RefreshInterval = proto.Int32(int32(temp))

				if len(row.Cells) < 8+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[8].String(), 10, 32)
				data.TimeToLive = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Policy806(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_Policy806Array{
			Arr: make([]*server.DB_Policy806, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Policy806{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.Time = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.FishId = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				arrStr = strings.Split(row.Cells[3].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[3].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Paths = arrInt

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.Count = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.Speed = proto.Int32(int32(temp))

				if len(row.Cells) < 6+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[6].String(), 10, 32)
				data.Event = proto.Int32(int32(temp))

				if len(row.Cells) < 7+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[7].String(), 10, 32)
				data.RefreshInterval = proto.Int32(int32(temp))

				if len(row.Cells) < 8+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[8].String(), 10, 32)
				data.TimeToLive = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Policy811(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_Policy811Array{
			Arr: make([]*server.DB_Policy811, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Policy811{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.Time = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.FishId = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				arrStr = strings.Split(row.Cells[3].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[3].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Paths = arrInt

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.Count = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.Speed = proto.Int32(int32(temp))

				if len(row.Cells) < 6+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[6].String(), 10, 32)
				data.Event = proto.Int32(int32(temp))

				if len(row.Cells) < 7+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[7].String(), 10, 32)
				data.RefreshInterval = proto.Int32(int32(temp))

				if len(row.Cells) < 8+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[8].String(), 10, 32)
				data.TimeToLive = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Policy812(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_Policy812Array{
			Arr: make([]*server.DB_Policy812, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Policy812{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.Time = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.FishId = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				arrStr = strings.Split(row.Cells[3].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[3].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Paths = arrInt

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.Count = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.Speed = proto.Int32(int32(temp))

				if len(row.Cells) < 6+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[6].String(), 10, 32)
				data.Event = proto.Int32(int32(temp))

				if len(row.Cells) < 7+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[7].String(), 10, 32)
				data.RefreshInterval = proto.Int32(int32(temp))

				if len(row.Cells) < 8+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[8].String(), 10, 32)
				data.TimeToLive = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Policy813(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_Policy813Array{
			Arr: make([]*server.DB_Policy813, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Policy813{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.Time = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.FishId = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				arrStr = strings.Split(row.Cells[3].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[3].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Paths = arrInt

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.Count = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.Speed = proto.Int32(int32(temp))

				if len(row.Cells) < 6+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[6].String(), 10, 32)
				data.Event = proto.Int32(int32(temp))

				if len(row.Cells) < 7+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[7].String(), 10, 32)
				data.RefreshInterval = proto.Int32(int32(temp))

				if len(row.Cells) < 8+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[8].String(), 10, 32)
				data.TimeToLive = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Policy814(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_Policy814Array{
			Arr: make([]*server.DB_Policy814, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Policy814{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.Time = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.FishId = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				arrStr = strings.Split(row.Cells[3].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[3].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Paths = arrInt

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.Count = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.Speed = proto.Int32(int32(temp))

				if len(row.Cells) < 6+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[6].String(), 10, 32)
				data.Event = proto.Int32(int32(temp))

				if len(row.Cells) < 7+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[7].String(), 10, 32)
				data.RefreshInterval = proto.Int32(int32(temp))

				if len(row.Cells) < 8+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[8].String(), 10, 32)
				data.TimeToLive = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Policy815(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_Policy815Array{
			Arr: make([]*server.DB_Policy815, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Policy815{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.Time = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.FishId = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				arrStr = strings.Split(row.Cells[3].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[3].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Paths = arrInt

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.Count = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.Speed = proto.Int32(int32(temp))

				if len(row.Cells) < 6+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[6].String(), 10, 32)
				data.Event = proto.Int32(int32(temp))

				if len(row.Cells) < 7+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[7].String(), 10, 32)
				data.RefreshInterval = proto.Int32(int32(temp))

				if len(row.Cells) < 8+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[8].String(), 10, 32)
				data.TimeToLive = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Policy816(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_Policy816Array{
			Arr: make([]*server.DB_Policy816, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Policy816{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.Time = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.FishId = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				arrStr = strings.Split(row.Cells[3].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[3].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Paths = arrInt

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.Count = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.Speed = proto.Int32(int32(temp))

				if len(row.Cells) < 6+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[6].String(), 10, 32)
				data.Event = proto.Int32(int32(temp))

				if len(row.Cells) < 7+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[7].String(), 10, 32)
				data.RefreshInterval = proto.Int32(int32(temp))

				if len(row.Cells) < 8+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[8].String(), 10, 32)
				data.TimeToLive = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_RobotGame(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_RobotGameArray{
			Arr: make([]*server.DB_RobotGame, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_RobotGame{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.EnterCoin = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.LeaveCoin = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[3].String(), 10, 32)
				data.GameTimes = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Sensitive_Words(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_Sensitive_WordsArray{
			Arr: make([]*server.DB_Sensitive_Words, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Sensitive_Words{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				data.Sensitive_Words = proto.String(row.Cells[1].String())

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Shop(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_ShopArray{
			Arr: make([]*server.DB_Shop, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Shop{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.ShowType = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				data.Name = proto.String(row.Cells[2].String())

				if len(row.Cells) < 3+1 {
					break
				}

				data.Picture = proto.String(row.Cells[3].String())

				if len(row.Cells) < 4+1 {
					break
				}

				data.Desc = proto.String(row.Cells[4].String())

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.Group = proto.Int32(int32(temp))

				if len(row.Cells) < 6+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[6].String(), 10, 32)
				data.Rebate = proto.Int32(int32(temp))

				if len(row.Cells) < 7+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[7].String(), 10, 32)
				data.Turn = proto.Int32(int32(temp))

				if len(row.Cells) < 8+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[8].String(), 10, 32)
				data.Special = proto.Int32(int32(temp))

				if len(row.Cells) < 9+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[9].String(), 10, 32)
				data.Costype = proto.Int32(int32(temp))

				if len(row.Cells) < 10+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[10].String(), 10, 32)
				data.Costp = proto.Int32(int32(temp))

				if len(row.Cells) < 11+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[11].String(), 10, 32)
				data.Cost = proto.Int32(int32(temp))

				if len(row.Cells) < 12+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[12].String(), 10, 32)
				data.Typee = proto.Int32(int32(temp))

				if len(row.Cells) < 13+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[13].String(), 10, 32)
				data.PropId = proto.Int32(int32(temp))

				if len(row.Cells) < 14+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[14].String(), 10, 32)
				data.Value = proto.Int32(int32(temp))

				if len(row.Cells) < 15+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[15].String(), 10, 32)
				data.Getype = proto.Int32(int32(temp))

				if len(row.Cells) < 16+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[16].String(), 10, 32)
				data.Tpyes = proto.Int32(int32(temp))

				if len(row.Cells) < 17+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[17].String(), 10, 32)
				data.Max = proto.Int32(int32(temp))

				if len(row.Cells) < 18+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[18].String(), 10, 32)
				data.ConditionId = proto.Int32(int32(temp))

				if len(row.Cells) < 19+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[19].String(), 10, 32)
				data.Reload = proto.Int32(int32(temp))

				if len(row.Cells) < 20+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[20].String(), 10, 32)
				data.Amount = proto.Int32(int32(temp))

				if len(row.Cells) < 21+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[21].String(), 10, 32)
				data.TimesLimit = proto.Int32(int32(temp))

				if len(row.Cells) < 22+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[22].String(), 10, 32)
				data.DayLimit = proto.Int32(int32(temp))

				if len(row.Cells) < 23+1 {
					break
				}

				data.PT_ItemCode = proto.String(row.Cells[23].String())

				if len(row.Cells) < 24+1 {
					break
				}

				data.PayPlatform_Flag = proto.String(row.Cells[24].String())

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Shop1(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_Shop1Array{
			Arr: make([]*server.DB_Shop1, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Shop1{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.ItemId = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.Page = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[3].String(), 10, 32)
				data.Order = proto.Int32(int32(temp))

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.Type = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				arrStr = strings.Split(row.Cells[5].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[5].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Location = arrInt

				if len(row.Cells) < 6+1 {
					break
				}

				data.Picture = proto.String(row.Cells[6].String())

				if len(row.Cells) < 7+1 {
					break
				}

				data.Name = proto.String(row.Cells[7].String())

				if len(row.Cells) < 8+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[8].String(), 10, 32)
				data.Ad = proto.Int32(int32(temp))

				if len(row.Cells) < 9+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[9].String(), 10, 32)
				data.AdTime = proto.Int32(int32(temp))

				if len(row.Cells) < 10+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[10].String(), 10, 32)
				data.RepeatTimes = proto.Int32(int32(temp))

				if len(row.Cells) < 11+1 {
					break
				}

				arrStr = strings.Split(row.Cells[11].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[11].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.CoolingTime = arrInt

				if len(row.Cells) < 12+1 {
					break
				}

				arrStr = strings.Split(row.Cells[12].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[12].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Label = arrInt

				if len(row.Cells) < 13+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[13].String(), 10, 32)
				data.Added = proto.Int32(int32(temp))

				if len(row.Cells) < 14+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[14].String(), 10, 32)
				data.Amount = proto.Int32(int32(temp))

				if len(row.Cells) < 15+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[15].String(), 10, 32)
				data.Consume = proto.Int32(int32(temp))

				if len(row.Cells) < 16+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[16].String(), 10, 32)
				data.ConsumptionAmount = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_SlotRateWeight(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_SlotRateWeightArray{
			Arr: make([]*server.DB_SlotRateWeight, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_SlotRateWeight{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.GameFreeId = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.Pos = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				arrStr = strings.Split(row.Cells[3].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[3].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.NormCol1 = arrInt

				if len(row.Cells) < 4+1 {
					break
				}

				arrStr = strings.Split(row.Cells[4].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[4].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.NormCol2 = arrInt

				if len(row.Cells) < 5+1 {
					break
				}

				arrStr = strings.Split(row.Cells[5].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[5].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.NormCol3 = arrInt

				if len(row.Cells) < 6+1 {
					break
				}

				arrStr = strings.Split(row.Cells[6].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[6].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.NormCol4 = arrInt

				if len(row.Cells) < 7+1 {
					break
				}

				arrStr = strings.Split(row.Cells[7].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[7].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.NormCol5 = arrInt

				if len(row.Cells) < 8+1 {
					break
				}

				arrStr = strings.Split(row.Cells[8].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[8].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.FreeCol1 = arrInt

				if len(row.Cells) < 9+1 {
					break
				}

				arrStr = strings.Split(row.Cells[9].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[9].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.FreeCol2 = arrInt

				if len(row.Cells) < 10+1 {
					break
				}

				arrStr = strings.Split(row.Cells[10].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[10].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.FreeCol3 = arrInt

				if len(row.Cells) < 11+1 {
					break
				}

				arrStr = strings.Split(row.Cells[11].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[11].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.FreeCol4 = arrInt

				if len(row.Cells) < 12+1 {
					break
				}

				arrStr = strings.Split(row.Cells[12].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[12].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.FreeCol5 = arrInt

				if len(row.Cells) < 13+1 {
					break
				}

				arrStr = strings.Split(row.Cells[13].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[13].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.MaryOut = arrInt

				if len(row.Cells) < 14+1 {
					break
				}

				arrStr = strings.Split(row.Cells[14].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[14].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.MaryMid = arrInt

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_SystemChance(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_SystemChanceArray{
			Arr: make([]*server.DB_SystemChance, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_SystemChance{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				data.Desc = proto.String(row.Cells[1].String())

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.ChanceType = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[3].String(), 10, 32)
				data.Coin = proto.Int32(int32(temp))

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.Rate = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Task(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_TaskArray{
			Arr: make([]*server.DB_Task, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Task{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				data.Name = proto.String(row.Cells[1].String())

				if len(row.Cells) < 2+1 {
					break
				}

				data.Desc = proto.String(row.Cells[2].String())

				if len(row.Cells) < 3+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[3].String(), 10, 32)
				data.Sort = proto.Int32(int32(temp))

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.TrunkTaskId = proto.Int32(int32(temp))

				if len(row.Cells) < 5+1 {
					break
				}

				arrStr = strings.Split(row.Cells[5].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[5].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.PostIds = arrInt

				if len(row.Cells) < 6+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[6].String(), 10, 32)
				data.PostLimitTime = proto.Int32(int32(temp))

				if len(row.Cells) < 7+1 {
					break
				}

				arrStr = strings.Split(row.Cells[7].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[7].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.AcceptConds = arrInt

				if len(row.Cells) < 8+1 {
					break
				}

				arrStr = strings.Split(row.Cells[8].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[8].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.CompleteConds = arrInt

				if len(row.Cells) < 9+1 {
					break
				}

				arrStr = strings.Split(row.Cells[9].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[9].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Prize = arrInt

				if len(row.Cells) < 10+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[10].String(), 10, 32)
				data.PeriodOfTime = proto.Int32(int32(temp))

				if len(row.Cells) < 11+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[11].String(), 10, 32)
				data.StartOfTime = proto.Int32(int32(temp))

				if len(row.Cells) < 12+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[12].String(), 10, 32)
				data.NeedDel = proto.Int32(int32(temp))

				if len(row.Cells) < 13+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[13].String(), 10, 32)
				data.Func = proto.Int32(int32(temp))

				if len(row.Cells) < 14+1 {
					break
				}

				arrStr = strings.Split(row.Cells[14].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[14].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.FuncParam = arrInt

				if len(row.Cells) < 15+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[15].String(), 10, 32)
				data.ZeroEffect = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_TaskCond(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_TaskCondArray{
			Arr: make([]*server.DB_TaskCond, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_TaskCond{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				data.Name = proto.String(row.Cells[1].String())

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.CondType = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				arrStr = strings.Split(row.Cells[3].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[3].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Param = arrInt

				if len(row.Cells) < 4+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[4].String(), 10, 32)
				data.Count = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_ThirdPlatformGameMapping(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_ThirdPlatformGameMappingArray{
			Arr: make([]*server.DB_ThirdPlatformGameMapping, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_ThirdPlatformGameMapping{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[1].String(), 10, 32)
				data.SystemGameID = proto.Int32(int32(temp))

				if len(row.Cells) < 2+1 {
					break
				}

				data.ThirdPlatformName = proto.String(row.Cells[2].String())

				if len(row.Cells) < 3+1 {
					break
				}

				data.ThirdGameID = proto.String(row.Cells[3].String())

				if len(row.Cells) < 4+1 {
					break
				}

				data.Desc = proto.String(row.Cells[4].String())

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.ScreenOrientationType = proto.Int32(int32(temp))

				if len(row.Cells) < 6+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[6].String(), 10, 32)
				data.ThirdID = proto.Int32(int32(temp))

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_Tips(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_TipsArray{
			Arr: make([]*server.DB_Tips, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_Tips{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				arrStr = strings.Split(row.Cells[1].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[1].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.GameId = arrInt

				if len(row.Cells) < 2+1 {
					break
				}

				data.Des = proto.String(row.Cells[2].String())

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func AgcConvertDB_VIP(fi, fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr := &server.DB_VIPArray{
			Arr: make([]*server.DB_VIP, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}

			if len(row.Cells) == 0 {
				break
			}

			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64

			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.DB_VIP{}

			for {

				if len(row.Cells) < 0+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
				data.Id = proto.Int32(int32(temp))

				if len(row.Cells) < 1+1 {
					break
				}

				data.Name = proto.String(row.Cells[1].String())

				if len(row.Cells) < 2+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[2].String(), 10, 32)
				data.Count = proto.Int32(int32(temp))

				if len(row.Cells) < 3+1 {
					break
				}

				arrStr = strings.Split(row.Cells[3].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[3].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.Param = arrInt

				if len(row.Cells) < 4+1 {
					break
				}

				if row.Cells[4].String() != "" {
					arrStr = strings.Split(row.Cells[4].String(), "|")
					data.ParamName = arrStr
				}

				if len(row.Cells) < 5+1 {
					break
				}

				temp, _ = strconv.ParseInt(row.Cells[5].String(), 10, 32)
				data.ExchangeRate = proto.Int32(int32(temp))

				if len(row.Cells) < 6+1 {
					break
				}

				arrStr = strings.Split(row.Cells[6].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[6].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.RewardPaotaiID = arrInt

				if len(row.Cells) < 7+1 {
					break
				}

				arrStr = strings.Split(row.Cells[7].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[7].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.RewardOutlineID = arrInt

				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil {
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}

		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}
		break //only fetch first sheet
	}
}

func main() {

	AgcConvertDB_ActSign(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_ActSign.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_ActSign.dat`)

	AgcConvertDB_Activity1(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Activity1.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Activity1.dat`)

	AgcConvertDB_AnimalColor(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_AnimalColor.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_AnimalColor.dat`)

	AgcConvertDB_ClientVer(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_ClientVer.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_ClientVer.dat`)

	AgcConvertDB_Createroom(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Createroom.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Createroom.dat`)

	AgcConvertDB_Fish(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Fish.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Fish.dat`)

	AgcConvertDB_FishHP(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_FishHP.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_FishHP.dat`)

	AgcConvertDB_FishHP2(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_FishHP2.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_FishHP2.dat`)

	AgcConvertDB_FishPool(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_FishPool.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_FishPool.dat`)

	AgcConvertDB_FishRate(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_FishRate.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_FishRate.dat`)

	AgcConvertDB_FishRoom(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_FishRoom.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_FishRoom.dat`)

	AgcConvertDB_FortuneGod_Odds(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_FortuneGod_Odds.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_FortuneGod_Odds.dat`)

	AgcConvertDB_FortuneGod_TurnRate(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_FortuneGod_TurnRate.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_FortuneGod_TurnRate.dat`)

	AgcConvertDB_FortuneGod_Weight(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_FortuneGod_Weight.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_FortuneGod_Weight.dat`)

	AgcConvertDB_FortuneGod_WeightCondition(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_FortuneGod_WeightCondition.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_FortuneGod_WeightCondition.dat`)

	AgcConvertDB_GamMatchLV(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_GamMatchLV.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_GamMatchLV.dat`)

	AgcConvertDB_GameCoinPool(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_GameCoinPool.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_GameCoinPool.dat`)

	AgcConvertDB_GameFree(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_GameFree.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_GameFree.dat`)

	AgcConvertDB_GameItem(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_GameItem.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_GameItem.dat`)

	AgcConvertDB_GameRule(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_GameRule.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_GameRule.dat`)

	AgcConvertDB_GameSubsidy(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_GameSubsidy.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_GameSubsidy.dat`)

	AgcConvertDB_Game_Drop(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Game_Drop.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Game_Drop.dat`)

	AgcConvertDB_Game_Introduction(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Game_Introduction.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Game_Introduction.dat`)

	AgcConvertDB_Game_Pet(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Game_Pet.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Game_Pet.dat`)

	AgcConvertDB_Game_Role(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Game_Role.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Game_Role.dat`)

	AgcConvertDB_Legend_Odds(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Legend_Odds.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Legend_Odds.dat`)

	AgcConvertDB_Legend_TurnRate(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Legend_TurnRate.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Legend_TurnRate.dat`)

	AgcConvertDB_Legend_Weight(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Legend_Weight.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Legend_Weight.dat`)

	AgcConvertDB_Legend_WeightCondition(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Legend_WeightCondition.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Legend_WeightCondition.dat`)

	AgcConvertDB_MatchRank(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_MatchRank.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_MatchRank.dat`)

	AgcConvertDB_Name(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Name.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Name.dat`)

	AgcConvertDB_NameBoy(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_NameBoy.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_NameBoy.dat`)

	AgcConvertDB_NameGirl(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_NameGirl.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_NameGirl.dat`)

	AgcConvertDB_PlayerInfo(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_PlayerInfo.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_PlayerInfo.dat`)

	AgcConvertDB_PlayerType(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_PlayerType.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_PlayerType.dat`)

	AgcConvertDB_Policy101(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Policy101.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Policy101.dat`)

	AgcConvertDB_Policy102(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Policy102.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Policy102.dat`)

	AgcConvertDB_Policy103(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Policy103.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Policy103.dat`)

	AgcConvertDB_Policy151(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Policy151.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Policy151.dat`)

	AgcConvertDB_Policy152(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Policy152.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Policy152.dat`)

	AgcConvertDB_Policy153(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Policy153.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Policy153.dat`)

	AgcConvertDB_Policy201(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Policy201.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Policy201.dat`)

	AgcConvertDB_Policy202(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Policy202.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Policy202.dat`)

	AgcConvertDB_Policy203(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Policy203.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Policy203.dat`)

	AgcConvertDB_Policy251(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Policy251.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Policy251.dat`)

	AgcConvertDB_Policy252(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Policy252.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Policy252.dat`)

	AgcConvertDB_Policy253(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Policy253.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Policy253.dat`)

	AgcConvertDB_Policy301(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Policy301.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Policy301.dat`)

	AgcConvertDB_Policy302(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Policy302.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Policy302.dat`)

	AgcConvertDB_Policy303(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Policy303.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Policy303.dat`)

	AgcConvertDB_Policy351(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Policy351.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Policy351.dat`)

	AgcConvertDB_Policy352(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Policy352.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Policy352.dat`)

	AgcConvertDB_Policy353(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Policy353.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Policy353.dat`)

	AgcConvertDB_Policy401(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Policy401.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Policy401.dat`)

	AgcConvertDB_Policy402(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Policy402.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Policy402.dat`)

	AgcConvertDB_Policy403(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Policy403.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Policy403.dat`)

	AgcConvertDB_Policy420(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Policy420.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Policy420.dat`)

	AgcConvertDB_Policy451(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Policy451.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Policy451.dat`)

	AgcConvertDB_Policy452(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Policy452.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Policy452.dat`)

	AgcConvertDB_Policy453(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Policy453.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Policy453.dat`)

	AgcConvertDB_Policy501(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Policy501.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Policy501.dat`)

	AgcConvertDB_Policy502(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Policy502.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Policy502.dat`)

	AgcConvertDB_Policy601(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Policy601.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Policy601.dat`)

	AgcConvertDB_Policy701(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Policy701.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Policy701.dat`)

	AgcConvertDB_Policy702(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Policy702.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Policy702.dat`)

	AgcConvertDB_Policy801(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Policy801.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Policy801.dat`)

	AgcConvertDB_Policy802(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Policy802.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Policy802.dat`)

	AgcConvertDB_Policy803(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Policy803.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Policy803.dat`)

	AgcConvertDB_Policy804(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Policy804.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Policy804.dat`)

	AgcConvertDB_Policy805(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Policy805.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Policy805.dat`)

	AgcConvertDB_Policy806(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Policy806.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Policy806.dat`)

	AgcConvertDB_Policy811(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Policy811.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Policy811.dat`)

	AgcConvertDB_Policy812(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Policy812.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Policy812.dat`)

	AgcConvertDB_Policy813(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Policy813.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Policy813.dat`)

	AgcConvertDB_Policy814(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Policy814.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Policy814.dat`)

	AgcConvertDB_Policy815(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Policy815.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Policy815.dat`)

	AgcConvertDB_Policy816(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Policy816.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Policy816.dat`)

	AgcConvertDB_RobotGame(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_RobotGame.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_RobotGame.dat`)

	AgcConvertDB_Sensitive_Words(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Sensitive_Words.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Sensitive_Words.dat`)

	AgcConvertDB_Shop(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Shop.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Shop.dat`)

	AgcConvertDB_Shop1(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Shop1.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Shop1.dat`)

	AgcConvertDB_SlotRateWeight(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_SlotRateWeight.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_SlotRateWeight.dat`)

	AgcConvertDB_SystemChance(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_SystemChance.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_SystemChance.dat`)

	AgcConvertDB_Task(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Task.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Task.dat`)

	AgcConvertDB_TaskCond(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_TaskCond.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_TaskCond.dat`)

	AgcConvertDB_ThirdPlatformGameMapping(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_ThirdPlatformGameMapping.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_ThirdPlatformGameMapping.dat`)

	AgcConvertDB_Tips(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_Tips.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_Tips.dat`)

	AgcConvertDB_VIP(`E:\gocode\trunk\src\games.yol.com\win88\xlsx\DB_VIP.xlsx`, `E:\gocode\trunk\src\games.yol.com\win88\data\DB_VIP.dat`)

}
