{{define "agc"}}
// Code generated by xlsx2proto.
// DO NOT EDIT!

package main
import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"runtime"
	"strconv"
	"strings"

	"games.yol.com/win88/proto"
	"games.yol.com/win88/protocol/server"
	"github.com/tealeg/xlsx"
)

var _ = strings.Split

{{ $a := .data }}{{ range $a }}{{ $elem := . }}
func AgcConvert{{ $elem.ProtoName }}(fi,fo string) {
	xlsxFile, err := xlsx.OpenFile(fi)
	if err != nil {
		fmt.Println("excel file open error:", err, "filename:", fi)
		return
	}

	if err := recover(); err != nil {
		fmt.Println(" panic,error=", err)
		var buf [4096]byte
		len := runtime.Stack(buf[:], false)
		fmt.Println("stack--->", string(buf[:len]))
	}
	for _, sheet := range xlsxFile.Sheets {
		arr:=&server.{{$elem.ProtoName}}Array{
			Arr:make([]*server.{{$elem.ProtoName}}, 0, len(sheet.Rows)),
		}

		for i, row := range sheet.Rows {
			if i <= 1 {
				continue
			}
			
			if len(row.Cells) == 0 {
				break
			}
			
			temp := int64(0)
			var arrInt []int32
			var arrInt64 []int64
			var arrStr []string
			var _ = arrInt
			var _ = arrStr
			var _ = arrInt64
			
			temp, _ = strconv.ParseInt(row.Cells[0].String(), 10, 32)
			data := &server.{{$elem.ProtoName}}{}
			
			for {
				{{ range $index, $col := $elem.Cols }}
				if len(row.Cells)<{{$index}}+1{
					break
				}
				{{if eq $col.ColType 1 }}
				temp, _ = strconv.ParseInt(row.Cells[{{$index}}].String(), 10, 32)
				data.{{$col.ColName}} = proto.Int32(int32(temp))
				{{end}}
				{{if eq $col.ColType 5 }}
				temp, _ = strconv.ParseInt(row.Cells[{{$index}}].String(), 10, 64)
				data.{{$col.ColName}} = proto.Int64(int64(temp))
				{{end}}				
				{{if eq $col.ColType 2 }}
				data.{{$col.ColName}} = proto.String(row.Cells[{{$index}}].String())
				{{end}}
				{{if eq $col.ColType 3 }}
				arrStr = strings.Split(row.Cells[{{$index}}].String(), "|")
				arrInt = nil
				if len(arrStr) > 0 && row.Cells[{{$index}}].String() != "" {
					arrInt = make([]int32, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 32)
						arrInt[i] = int32(temp)
					}
				}
				data.{{$col.ColName}} = arrInt
				{{end}}
				{{if eq $col.ColType 4 }}
				if row.Cells[{{$index}}].String() != "" {
					arrStr = strings.Split(row.Cells[{{$index}}].String(), "|")
					data.{{$col.ColName}} = arrStr
				}
				{{end}}
				{{if eq $col.ColType 6 }}
				arrStr = strings.Split(row.Cells[{{$index}}].String(), "|")
				arrInt64 = nil
				if len(arrStr) > 0 && row.Cells[{{$index}}].String() != "" {
					arrInt = make([]int64, len(arrStr), len(arrStr))
					for i, v := range arrStr {
						temp, _ = strconv.ParseInt(strings.TrimSpace(v), 10, 64)
						arrInt64[i] = int64(temp)
					}
				}
				data.{{$col.ColName}} = arrInt64
				{{end}}												
				{{end}}
				
				break
			}
			arr.Arr = append(arr.Arr, data)
		}

		byteData, err := proto.Marshal(arr)
		if err == nil{
			ioutil.WriteFile(fo, byteData, os.ModePerm)
		}
		
		byteData, err = json.MarshalIndent(arr, "", "\t")
		if err == nil {
			foJson := strings.Replace(fo, ".dat", ".json", -1)
			ioutil.WriteFile(foJson, byteData, os.ModePerm)
		}		
		break //only fetch first sheet
	}
}
	{{end}}

func main(){
{{ $a := .data }}{{ $opath := .opath }}{{ range $a }}{{ $elem := . }}
	AgcConvert{{$elem.ProtoName}}(`{{$elem.AbsPath}}`,`{{$opath}}\{{$elem.ProtoName}}.dat`)
{{end}}
}
{{end}}